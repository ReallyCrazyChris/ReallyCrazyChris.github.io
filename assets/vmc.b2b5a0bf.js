import{d as W}from"./index.42812f5f.js";import{u as A}from"./mqtt-vue-hook.es.c8aea688.js";const C=W("gps",{state:()=>({lon:0,lat:0,sog:0,heading:0,accuracy:5,watchid:null,wathcoptions:{enableHighAccuracy:!0,timeout:3e4,maximumAge:0}}),actions:{watchsuccess(m){this.lon=m.coords.longitude,this.lat=m.coords.latitude,this.sog=m.coords.speed,this.heading=m.coords.heading,this.accuracy=m.coords.accuracy},watcherror(m){console.error(`ERROR(${m.code}): ${m.message}`)},watchPosition(){this.watchid=navigator.geolocation.watchPosition(this.watchsuccess,this.watcherror,this.wathcoptions)},clearWatchPosition(){navigator.geolocation.clearWatch(this.watchid)}}}),J=C(),V=()=>J;let D="\u202F";class c{static get separator(){return D}static set separator(t){D=t}static parse(t){if(!isNaN(parseFloat(t))&&isFinite(t))return Number(t);const s=String(t).trim().replace(/^-/,"").replace(/[NSEW]$/i,"").split(/[^0-9.,]+/);if(s[s.length-1]==""&&s.splice(s.length-1),s=="")return NaN;let n=null;switch(s.length){case 3:n=s[0]/1+s[1]/60+s[2]/3600;break;case 2:n=s[0]/1+s[1]/60;break;case 1:n=s[0];break;default:return NaN}return/^-|[WS]$/i.test(t.trim())&&(n=-n),Number(n)}static toDms(t,s="d",n=void 0){if(isNaN(t)||typeof t=="string"&&t.trim()==""||typeof t=="boolean"||t==1/0||t==null)return null;if(n===void 0)switch(s){case"d":case"deg":n=4;break;case"dm":case"deg+min":n=2;break;case"dms":case"deg+min+sec":n=0;break;default:s="d",n=4;break}t=Math.abs(t);let a=null,i=null,o=null,e=null;switch(s){default:case"d":case"deg":i=t.toFixed(n),i<100&&(i="0"+i),i<10&&(i="0"+i),a=i+"\xB0";break;case"dm":case"deg+min":i=Math.floor(t),o=(t*60%60).toFixed(n),o==60&&(o=0 .toFixed(n),i++),i=("000"+i).slice(-3),o<10&&(o="0"+o),a=i+"\xB0"+c.separator+o+"\u2032";break;case"dms":case"deg+min+sec":i=Math.floor(t),o=Math.floor(t*3600/60)%60,e=(t*3600%60).toFixed(n),e==60&&(e=0 .toFixed(n),o++),o==60&&(o=0,i++),i=("000"+i).slice(-3),o=("00"+o).slice(-2),e<10&&(e="0"+e),a=i+"\xB0"+c.separator+o+"\u2032"+c.separator+e+"\u2033";break}return a}static toLat(t,s,n){const a=c.toDms(c.wrap90(t),s,n);return a===null?"\u2013":a.slice(1)+c.separator+(t<0?"S":"N")}static toLon(t,s,n){const a=c.toDms(c.wrap180(t),s,n);return a===null?"\u2013":a+c.separator+(t<0?"W":"E")}static toBrng(t,s,n){const a=c.toDms(c.wrap360(t),s,n);return a===null?"\u2013":a.replace("360","0")}static fromLocale(t){const s=123456.789 .toLocaleString(),n={thousands:s.slice(3,4),decimal:s.slice(7,8)};return t.replace(n.thousands,"\u205C").replace(n.decimal,".").replace("\u205C",",")}static toLocale(t){const s=123456.789 .toLocaleString(),n={thousands:s.slice(3,4),decimal:s.slice(7,8)};return t.replace(/,([0-9])/,"\u205C$1").replace(".",n.decimal).replace("\u205C",n.thousands)}static compassPoint(t,s=3){if(![1,2,3].includes(Number(s)))throw new RangeError(`invalid precision \u2018${s}\u2019`);t=c.wrap360(t);const n=["N","NNE","NE","ENE","E","ESE","SE","SSE","S","SSW","SW","WSW","W","WNW","NW","NNW"],a=4*2**(s-1);return n[Math.round(t*a/360)%a*16/a]}static wrap90(t){if(-90<=t&&t<=90)return t;const s=t,n=90,a=360;return 4*n/a*Math.abs(((s-a/4)%a+a)%a-a/2)-n}static wrap180(t){if(-180<=t&&t<=180)return t;const s=t,n=180,a=360;return((2*n*s/a-a/2)%a+a)%a-n}static wrap360(t){if(0<=t&&t<360)return t;const s=t,n=180,a=360;return(2*n*s/a%a+a)%a}}Number.prototype.toRadians=function(){return this*Math.PI/180};Number.prototype.toDegrees=function(){return this*180/Math.PI};const d=Math.PI;class h{constructor(t,s){if(isNaN(t))throw new TypeError(`invalid lat \u2018${t}\u2019`);if(isNaN(s))throw new TypeError(`invalid lon \u2018${s}\u2019`);this._lat=c.wrap90(Number(t)),this._lon=c.wrap180(Number(s))}get lat(){return this._lat}get latitude(){return this._lat}set lat(t){if(this._lat=isNaN(t)?c.wrap90(c.parse(t)):c.wrap90(Number(t)),isNaN(this._lat))throw new TypeError(`invalid lat \u2018${t}\u2019`)}set latitude(t){if(this._lat=isNaN(t)?c.wrap90(c.parse(t)):c.wrap90(Number(t)),isNaN(this._lat))throw new TypeError(`invalid latitude \u2018${t}\u2019`)}get lon(){return this._lon}get lng(){return this._lon}get longitude(){return this._lon}set lon(t){if(this._lon=isNaN(t)?c.wrap180(c.parse(t)):c.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid lon \u2018${t}\u2019`)}set lng(t){if(this._lon=isNaN(t)?c.wrap180(c.parse(t)):c.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid lng \u2018${t}\u2019`)}set longitude(t){if(this._lon=isNaN(t)?c.wrap180(c.parse(t)):c.wrap180(Number(t)),isNaN(this._lon))throw new TypeError(`invalid longitude \u2018${t}\u2019`)}static get metresToKm(){return 1/1e3}static get metresToMiles(){return 1/1609.344}static get metresToNauticalMiles(){return 1/1852}static parse(...t){if(t.length==0)throw new TypeError("invalid (empty) point");if(t[0]===null||t[1]===null)throw new TypeError("invalid (null) point");let s,n;if(t.length==2&&([s,n]=t,s=c.wrap90(c.parse(s)),n=c.wrap180(c.parse(n)),isNaN(s)||isNaN(n)))throw new TypeError(`invalid point \u2018${t.toString()}\u2019`);if(t.length==1&&typeof t[0]=="string"&&([s,n]=t[0].split(","),s=c.wrap90(c.parse(s)),n=c.wrap180(c.parse(n)),isNaN(s)||isNaN(n)))throw new TypeError(`invalid point \u2018${t[0]}\u2019`);if(t.length==1&&typeof t[0]=="object"){const a=t[0];if(a.type=="Point"&&Array.isArray(a.coordinates)?[n,s]=a.coordinates:(a.latitude!=null&&(s=a.latitude),a.lat!=null&&(s=a.lat),a.longitude!=null&&(n=a.longitude),a.lng!=null&&(n=a.lng),a.lon!=null&&(n=a.lon),s=c.wrap90(c.parse(s)),n=c.wrap180(c.parse(n))),isNaN(s)||isNaN(n))throw new TypeError(`invalid point \u2018${JSON.stringify(t[0])}\u2019`)}if(isNaN(s)||isNaN(n))throw new TypeError(`invalid point \u2018${t.toString()}\u2019`);return new h(s,n)}distanceTo(t,s=6371e3){if(t instanceof h||(t=h.parse(t)),isNaN(s))throw new TypeError(`invalid radius \u2018${s}\u2019`);const n=s,a=this.lat.toRadians(),i=this.lon.toRadians(),o=t.lat.toRadians(),e=t.lon.toRadians(),l=o-a,r=e-i,M=Math.sin(l/2)*Math.sin(l/2)+Math.cos(a)*Math.cos(o)*Math.sin(r/2)*Math.sin(r/2),u=2*Math.atan2(Math.sqrt(M),Math.sqrt(1-M));return n*u}initialBearingTo(t){if(t instanceof h||(t=h.parse(t)),this.equals(t))return NaN;const s=this.lat.toRadians(),n=t.lat.toRadians(),a=(t.lon-this.lon).toRadians(),i=Math.cos(s)*Math.sin(n)-Math.sin(s)*Math.cos(n)*Math.cos(a),o=Math.sin(a)*Math.cos(n),l=Math.atan2(o,i).toDegrees();return c.wrap360(l)}finalBearingTo(t){t instanceof h||(t=h.parse(t));const s=t.initialBearingTo(this)+180;return c.wrap360(s)}midpointTo(t){t instanceof h||(t=h.parse(t));const s=this.lat.toRadians(),n=this.lon.toRadians(),a=t.lat.toRadians(),i=(t.lon-this.lon).toRadians(),o={x:Math.cos(s),y:0,z:Math.sin(s)},e={x:Math.cos(a)*Math.cos(i),y:Math.cos(a)*Math.sin(i),z:Math.sin(a)},l={x:o.x+e.x,y:o.y+e.y,z:o.z+e.z},r=Math.atan2(l.z,Math.sqrt(l.x*l.x+l.y*l.y)),M=n+Math.atan2(l.y,l.x),u=r.toDegrees(),f=M.toDegrees();return new h(u,f)}intermediatePointTo(t,s){if(t instanceof h||(t=h.parse(t)),this.equals(t))return new h(this.lat,this.lon);const n=this.lat.toRadians(),a=this.lon.toRadians(),i=t.lat.toRadians(),o=t.lon.toRadians(),e=i-n,l=o-a,r=Math.sin(e/2)*Math.sin(e/2)+Math.cos(n)*Math.cos(i)*Math.sin(l/2)*Math.sin(l/2),M=2*Math.atan2(Math.sqrt(r),Math.sqrt(1-r)),u=Math.sin((1-s)*M)/Math.sin(M),f=Math.sin(s*M)/Math.sin(M),N=u*Math.cos(n)*Math.cos(a)+f*Math.cos(i)*Math.cos(o),w=u*Math.cos(n)*Math.sin(a)+f*Math.cos(i)*Math.sin(o),g=u*Math.sin(n)+f*Math.sin(i),b=Math.atan2(g,Math.sqrt(N*N+w*w)),R=Math.atan2(w,N),x=b.toDegrees(),B=R.toDegrees();return new h(x,B)}destinationPoint(t,s,n=6371e3){const a=t/n,i=Number(s).toRadians(),o=this.lat.toRadians(),e=this.lon.toRadians(),l=Math.sin(o)*Math.cos(a)+Math.cos(o)*Math.sin(a)*Math.cos(i),r=Math.asin(l),M=Math.sin(i)*Math.sin(a)*Math.cos(o),u=Math.cos(a)-Math.sin(o)*l,f=e+Math.atan2(M,u),N=r.toDegrees(),w=f.toDegrees();return new h(N,w)}static intersection(t,s,n,a){if(t instanceof h||(t=h.parse(t)),n instanceof h||(n=h.parse(n)),isNaN(s))throw new TypeError(`invalid brng1 \u2018${s}\u2019`);if(isNaN(a))throw new TypeError(`invalid brng2 \u2018${a}\u2019`);const i=t.lat.toRadians(),o=t.lon.toRadians(),e=n.lat.toRadians(),l=n.lon.toRadians(),r=Number(s).toRadians(),M=Number(a).toRadians(),u=e-i,f=l-o,N=2*Math.asin(Math.sqrt(Math.sin(u/2)*Math.sin(u/2)+Math.cos(i)*Math.cos(e)*Math.sin(f/2)*Math.sin(f/2)));if(Math.abs(N)<Number.EPSILON)return new h(t.lat,t.lon);const w=(Math.sin(e)-Math.sin(i)*Math.cos(N))/(Math.sin(N)*Math.cos(i)),g=(Math.sin(i)-Math.sin(e)*Math.cos(N))/(Math.sin(N)*Math.cos(e)),b=Math.acos(Math.min(Math.max(w,-1),1)),R=Math.acos(Math.min(Math.max(g,-1),1)),x=Math.sin(l-o)>0?b:2*d-b,B=Math.sin(l-o)>0?2*d-R:R,T=r-x,y=B-M;if(Math.sin(T)==0&&Math.sin(y)==0||Math.sin(T)*Math.sin(y)<0)return null;const k=-Math.cos(T)*Math.cos(y)+Math.sin(T)*Math.sin(y)*Math.cos(N),$=Math.atan2(Math.sin(N)*Math.sin(T)*Math.sin(y),Math.cos(y)+Math.cos(T)*k),q=Math.asin(Math.min(Math.max(Math.sin(i)*Math.cos($)+Math.cos(i)*Math.sin($)*Math.cos(r),-1),1)),F=Math.atan2(Math.sin(r)*Math.sin($)*Math.cos(i),Math.cos($)-Math.sin(i)*Math.sin(q)),O=o+F,z=q.toDegrees(),I=O.toDegrees();return new h(z,I)}crossTrackDistanceTo(t,s,n=6371e3){t instanceof h||(t=h.parse(t)),s instanceof h||(s=h.parse(s));const a=n;if(this.equals(t))return 0;const i=t.distanceTo(this,a)/a,o=t.initialBearingTo(this).toRadians(),e=t.initialBearingTo(s).toRadians();return Math.asin(Math.sin(i)*Math.sin(o-e))*a}alongTrackDistanceTo(t,s,n=6371e3){t instanceof h||(t=h.parse(t)),s instanceof h||(s=h.parse(s));const a=n;if(this.equals(t))return 0;const i=t.distanceTo(this,a)/a,o=t.initialBearingTo(this).toRadians(),e=t.initialBearingTo(s).toRadians(),l=Math.asin(Math.sin(i)*Math.sin(o-e));return Math.acos(Math.cos(i)/Math.abs(Math.cos(l)))*Math.sign(Math.cos(e-o))*a}maxLatitude(t){const s=Number(t).toRadians(),n=this.lat.toRadians();return Math.acos(Math.abs(Math.sin(s)*Math.cos(n))).toDegrees()}static crossingParallels(t,s,n){if(t.equals(s))return null;const a=Number(n).toRadians(),i=t.lat.toRadians(),o=t.lon.toRadians(),e=s.lat.toRadians(),r=s.lon.toRadians()-o,M=Math.sin(i)*Math.cos(e)*Math.cos(a)*Math.sin(r),u=Math.sin(i)*Math.cos(e)*Math.cos(a)*Math.cos(r)-Math.cos(i)*Math.sin(e)*Math.cos(a),f=Math.cos(i)*Math.cos(e)*Math.sin(a)*Math.sin(r);if(f*f>M*M+u*u)return null;const N=Math.atan2(-u,M),w=Math.acos(f/Math.sqrt(M*M+u*u)),g=o+N-w,b=o+N+w,R=g.toDegrees(),x=b.toDegrees();return{lon1:c.wrap180(R),lon2:c.wrap180(x)}}rhumbDistanceTo(t,s=6371e3){t instanceof h||(t=h.parse(t));const n=s,a=this.lat.toRadians(),i=t.lat.toRadians(),o=i-a;let e=Math.abs(t.lon-this.lon).toRadians();Math.abs(e)>d&&(e=e>0?-(2*d-e):2*d+e);const l=Math.log(Math.tan(i/2+d/4)/Math.tan(a/2+d/4)),r=Math.abs(l)>1e-11?o/l:Math.cos(a);return Math.sqrt(o*o+r*r*e*e)*n}rhumbBearingTo(t){if(t instanceof h||(t=h.parse(t)),this.equals(t))return NaN;const s=this.lat.toRadians(),n=t.lat.toRadians();let a=(t.lon-this.lon).toRadians();Math.abs(a)>d&&(a=a>0?-(2*d-a):2*d+a);const i=Math.log(Math.tan(n/2+d/4)/Math.tan(s/2+d/4)),e=Math.atan2(a,i).toDegrees();return c.wrap360(e)}rhumbDestinationPoint(t,s,n=6371e3){const a=this.lat.toRadians(),i=this.lon.toRadians(),o=Number(s).toRadians(),e=t/n,l=e*Math.cos(o);let r=a+l;Math.abs(r)>d/2&&(r=r>0?d-r:-d-r);const M=Math.log(Math.tan(r/2+d/4)/Math.tan(a/2+d/4)),u=Math.abs(M)>1e-11?l/M:Math.cos(a),f=e*Math.sin(o)/u,N=i+f,w=r.toDegrees(),g=N.toDegrees();return new h(w,g)}rhumbMidpointTo(t){t instanceof h||(t=h.parse(t));const s=this.lat.toRadians();let n=this.lon.toRadians();const a=t.lat.toRadians(),i=t.lon.toRadians();Math.abs(i-n)>d&&(n+=2*d);const o=(s+a)/2,e=Math.tan(d/4+s/2),l=Math.tan(d/4+a/2),r=Math.tan(d/4+o/2);let M=((i-n)*Math.log(r)+n*Math.log(l)-i*Math.log(e))/Math.log(l/e);isFinite(M)||(M=(n+i)/2);const u=o.toDegrees(),f=M.toDegrees();return new h(u,f)}static areaOf(t,s=6371e3){const n=s,a=t[0].equals(t[t.length-1]);a||t.push(t[0]);const i=t.length-1;let o=0;for(let r=0;r<i;r++){const M=t[r].lat.toRadians(),u=t[r+1].lat.toRadians(),f=(t[r+1].lon-t[r].lon).toRadians();o+=2*Math.atan2(Math.tan(f/2)*(Math.tan(M/2)+Math.tan(u/2)),1+Math.tan(M/2)*Math.tan(u/2))}l(t)&&(o=Math.abs(o)-2*d);const e=Math.abs(o*n*n);return a||t.pop(),e;function l(r){let M=0,u=r[0].initialBearingTo(r[1]);for(let w=0;w<r.length-1;w++){const g=r[w].initialBearingTo(r[w+1]),b=r[w].finalBearingTo(r[w+1]);M+=(g-u+540)%360-180,M+=(b-g+540)%360-180,u=b}return M+=(r[0].initialBearingTo(r[1])-u+540)%360-180,Math.abs(M)<90}}equals(t){return t instanceof h||(t=h.parse(t)),!(Math.abs(this.lat-t.lat)>Number.EPSILON||Math.abs(this.lon-t.lon)>Number.EPSILON)}toGeoJSON(){return{type:"Point",coordinates:[this.lon,this.lat]}}toString(t="d",s=void 0){if(!["d","dm","dms","n"].includes(t))throw new RangeError(`invalid format \u2018${t}\u2019`);if(t=="n")return s==null&&(s=4),`${this.lat.toFixed(s)},${this.lon.toFixed(s)}`;const n=c.toLat(this.lat,t,s),a=c.toLon(this.lon,t,s);return`${n}, ${a}`}}const E=A(),v=V(),G=W("vmc",{state:()=>({sog:0,vmc:0,efficiency:0,bearing:0,distance:0,lon:0,lat:0}),actions:{setCoordinates(m,t){this.lon=m,this.lat=t,E.isConnected&&(console.log("publishVMCCoordinates",this.lon,this.lat),E.publish("vmc",JSON.stringify({lon:this.lon,lat:this.lat}),0,{retain:!0}))},update(m,t,s,n){const a=new h(t,m),i=new h(this.lat,this.lon);this.bearing=a.initialBearingTo(i),this.distance=Math.round(a.distanceTo(i));var o=this.bearing-s;o=o%360,o<0&&(o+=360);const e=o*Math.PI/180;this.sog=Math.round(19.4384*n)/10;const l=Math.round(19.4384*n*Math.cos(e))/10;isNaN(l)?this.vmc=0:this.vmc=l;const r=Math.round(100*(this.vmc/(1.94384*n)))||0;isNaN(r)?this.efficiency=0:this.efficiency=r},publishVmcState(){E.isConnected&&E.publish("vmc",JSON.stringify({lon:this.lon,lat:this.lat}),0,{retain:!0})}}}),P=G();E.registerEvent("vmc",(m,t)=>{const s=JSON.parse(t.toString());console.log("patch vmc",s),P.$patch(s)});v.$subscribe(()=>{P.update(v.lon,v.lat,v.heading,v.sog)});v.watchPosition();const p=()=>P;export{V as a,p as u};
